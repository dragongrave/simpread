> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.kancloud.cn](https://www.kancloud.cn/hanxt/springsecurity/2025935)

> HttpBasic、formLogin验证模式，RBAC权限模型，JWT、OAuth2等核心技术。验证码、图片验证码、单点登录及社交媒体登录等功能全覆盖。

随着企业的应用规模不断增大，一个单体应用很难满足用户量增长的需求，这就需要我们将单体应用集群化部署，或者将单体应用微服务化。在这个过程中，就涉及到两个问题:

*   集群应用之间如何共享 session，我在应用 1 上保存的数据，在访问应用 2 接口的时候还可不可以获取到了？理想的答案是可以
*   我在访问应用 1 的时候已经登陆了，作为统一体系下的子应用，我再访问应用 2 还需要再次登陆么？理想的答案是不需要

为了让以上两个问题获得理想的答案，通常可以使用以下四种方案

方案一：基于 session 共享
-----------------

### 1.1. 单个应用的 session 应用

要了解集群的 session 如何共享，一定要先了解单体应用是如何使用 session 的  
![](https://img.kancloud.cn/17/9b/179bdb8c1a8dfa791dbb916c05be72d7_1200x473.png)

*   单体应用用户登陆之后，将状态信息保存到 session 里面。服务端自动维护 sessionid，即将 sessionid 写入 cookie。
*   cookie 随着 HTTP 响应，被自动保存到浏览器端。
*   当用户再次发送 HTTP 请求，sessionid 随着 cookies 被自动带回服务器端 (浏览器行为，无需编码)
*   服务器端根据 sessionid，可以找回该用户之前保存在 session 里面的数据。

### 1.2. 集群应用的 Session 共享

*   同一 IP(域名)，不同端口，在同一个浏览器 cookies 是共享的。不同 IP(域名) 的 Cookies，在同一个浏览器 Cookies 肯定不共享的。对于这种情况需要在集群应用的前面加上负载均衡器逆向代理，如：nginx，haproxy。让客户端看上去访问的是同一个 IP(代理 IP)，从而浏览器认为基于这个 IP 的 Cookies 是共享的。
    
*   SESSION 正常是由 Servlet 容器来维护的（内存里面，每个服务器内存是不共享的），这样集群节点之间 SESSION 就无法共享。如果希望 Session 共享，就需要把 sessionID 的存储放到一个统一的地方，如：redis。SessionID 的维护交给 Spring session 则更加方便。
    
*   除了 Cookies 可以维持 Sessionid，Spring Session 还提供了了另外一种方式，就是使用 header 传递 SESSIONID。目的是为了方便类似于手机这种没有 cookies 的客户端进行 session 共享。
    

![](https://img.kancloud.cn/c5/95/c5957d41164e027d2404327ce4a5df5d_1051x587.png)

这种应用架构方式，**特别适合一份应用代码启动多个实例，** 也就是说上图中的应用 1、应用 2、应用 3 是从一份代码的基础上启动的三个实例实现共享 session。因为代码是一样的，session 状态信息是一样的，所以客户端的 sessionid 一致就被认为是同一个用户，在一个实例上登陆，就可以访问其他实例的接口。**因为类似于 Spring Security 这种权限管理框架，权限信息都在 session 里。**

方案二：基于 CAS 单点登录
---------------

我们刚才讲的第一种方案特别适合一份应用代码启动多个实例的场景。那下面为大家介绍的 CAS 方案，就比较适合**不同的代码启动的应用实例之间实现单点登录**。比如说：chrome、youtube、gmail 都是谷歌公司的，但是不同的产品，我们在 chrome 浏览器登陆了，就直接可以访问 YouTube 和 gmail，这是怎么做的？

### 2.1. 第一次访问应用 1

![](https://img.kancloud.cn/aa/91/aa918ae7cc4c547a6cae18d6fbff2596_837x473.png)  
需要在应用服务之外单独搭建一个 CAS Server，也就是登录认证服务器

1.  用户访问应用 1 的资源
2.  应用 1 发现这个用户没有登录，响应 302，告知浏览器将该用户的请求重定向到 CAS Server 进行登录
3.  浏览器重定向到 CAS Server
4.  CAS Server 收到请求，同样确认该用户未登录，响应 login 页面让其登录
5.  用户输入正确用户名和密码认证后，CAS Server 为该用户颁发 TGC 和 ST，并在自己的内存里保存 TGT。并告知浏览器重定向回到应用 1
    *   TGC 与 TGT 的关系就好像 sessionid 与 session 的关系。TGT 中保存了该登陆用户的信息，TGC 是用于匹配这些信息的钥匙
    *   TGC 保存在 cookies 里面，在浏览器请求与响应中自动携带。
    *   ST 比较单纯，Service Ticket，用于访问服务资源，并且只能使用一次
6.  浏览器重定向回到应用 1 的资源，并携带 (TGC、ST)
7.  应用 1 收到重定向请求后，向 CAS Server 发请求，根据 TGC 找到 TGT，并验证 ST 是否有效
8.  CAS Server 验证该 ST 是有效的，应用 1 已知该用户合法。在自己的应用里面记录用户的 session 信息，并将用户请求的资源响应回浏览器

> 登录认证不等于服务接口鉴权，这里只是代表用户登录成功了，不代表你进系统之后什么接口都可以访问！接口授权鉴权的工作仍然是 Spring Security 来做。

### 2.2. 第二次访问应用 1

用户已经访问过应用 1 了，并且登录认证成功，第一次登录认证成功之后，应用 1 在自己的应用 session 内记录用户状态信息，因此这里就直接通过了，不需要二次登录认证。

### 2.3. 在应用 1 内调用应用 2 资源

现在问题来了，chrome（应用 1）登陆成功了，我们要访问 gmail（应用 2），都是谷歌的产品，你不好让用户重新登陆吧？

![](https://img.kancloud.cn/33/8b/338b5b8c42522fd545b5bdbb3eace9e2_745x665.png)

1.  用户浏览应用 1 的时候，访问了应用 2 的页面或接口（上一次认证成功颁发的 TGC 一直还携带着）
2.  应用 2 发现该用户重来没有访问过我，所以应用 2 认为该用户没有权限访问我的资源
3.  告知浏览器重定向到 CAS Server 进行认证
4.  认证服务器根据 TGC 找到上一次保存的 TGT，找到之后即表示认证成功，签发 ST
5.  认证成功之后响应 302，告知浏览器重定向回到应用 2，
6.  应用 2 在收到重定向请求之后，重复 2.1 中的 7 和 8 步骤，向 CAS Server 验证 ST 的有效性，如果有效，在自己的应用里面记录用户的 session 信息，并将用户请求的资源响应回浏览器

这样这个用户以后访问应用 2 就不需要再次认证了。

> 有的朋友可能会问，这只解决了应用之间单点登陆的问题，那 session 共享的问题呢？一般来说，不同代码启动的应用实例之间是不需要共享 session 的 (除了认证数据)，认证过程已经交给 CAS Server 实现了。还有共享 session 的必要么？

三、基于 JWT
--------

上面的这个 CAS Server 集中验证的方式虽然能够实现单点登录，但是请求认证过程过于复杂，不够灵活。需要独立维护一个 CAS Server，现在我们想让应用的部署更灵活一些，而且不需要 CAS 的外部依赖，不需要 session 共享的前端代理和后端 redis session 集中存储，这些我们都不想要。

如果没有独立的状态存储，这种应用就是无状态应用。有状态应用用户的数据是存储在 session 里面，或者 CAS Server 提供认证状态，或者 redis session 状态集中存储。那么无状态应用，用户的登录状态、角色、权限这些数据放在哪？答案就是 JWT 令牌，JWT 实现也有两种方式

*   方式一：JWT 中只含用户的唯一标志，用户每一次访问资源都使用该唯一标志重新去数据库加载用户状态信息数据。
*   方式二：JWT 中包含所有的用户状态信息数据，这样做的坏处是增加了网络带宽的负担，但是因为完全不需要 session，从而降低了对于内存的需求；也降低了数据库用户状态数据查询操作的需求。

用户在应用 A 上登录认证，应用 A 会颁发给他一个 JWT 令牌（一个包含若干用户状态信息的字符串）。当用户访问应用 B 接口的时候，将这个字符串交给应用 B，应用 B 根据 Token 中的内容进行鉴权。不同的应用之间按照统一标准发放 JWT 令牌，统一标准验证 JWT 令牌。从而你在应用 A 上获得的令牌，在应用 B 上也被认可，当然这样这些应用之间底层数据库必须是同一套用户、角色、权限数据。

![](https://img.kancloud.cn/f6/de/f6de020bb5879c0a3ee53371b0738ee4_878x525.png)

如果说 CAS Server 是网盘，那么 JWT 就是 U 盘。你品、你细品。U 盘容易丢，丢了怎么办，关于 JWT 安全相关的问题，我们后面章节会为大家介绍。

四、基于 OAuth2（也可以加 JWT）
---------------------

以上的所有的单点集群登陆方案，都是有一个前提就是：应用 A、应用 B、应用 1、应用 2、应用 3 都是你们公司的，你们公司内部应用之间进行单点登陆验证。

但是我想大家都见过这样一个场景：我们登录某一个网站，然后使用的是我们在 QQ、微信上保存的用户数据。也就是说第三方应用想使用某个权威平台的用户数据做登录认证，那么这个权威平台该如何对第三方应用提供认证服务？目前比较通用的做法就是 OAuth2（现代化的社交媒体网站登录基本都使用 OAuth2）

OAuth2 协议的授权码模式，和 JWT 令牌的原理有些类似，但是它和 JWT 又不相同，OAuth2 协议有独立的认证服务器。这个我们后面章节会为大家详细介绍，这里知道有这么一个方案和它的应用场景就可以了。